import { r as __toESM, t as require_react } from "./react-DOLv65KA.js";
import { $ as ScrollRestoration, $t as useMatch, A as HashRouter, At as matchPath, B as NavLink, Bt as useAsyncError, C as CRITICAL_CSS_DATA_ATTRIBUTE, Ct as generatePath, D as FetchersContext, Dt as invariant, E as ErrorResponseImpl, Et as hydrationRouteProperties, F as Link, Ft as renderMatches, G as RemixErrorBoundary, Gt as useFetchers, H as NavigationContext, Ht as useBeforeUnload, I as Links, It as replace, J as Router, Jt as useHref, K as Route, Kt as useFogOFWarDiscovery, L as LocationContext, Lt as resolvePath, M as IDLE_BLOCKER, Mt as parsePath, N as IDLE_FETCHER, Nt as redirect, O as Form, Ot as isRouteErrorResponse, P as IDLE_NAVIGATION, Pt as redirectDocument, Q as Scripts, Qt as useLocation, R as MemoryRouter, Rt as shouldHydrateRouteLoader, S as BrowserRouter, St as decodeViaTurboStream, T as DataRouterStateContext, Tt as getTurboStreamSingleFetchDataStrategy, U as Outlet, Ut as useBlocker, V as Navigate, Vt as useAsyncValue, W as PrefetchPageLinks, Wt as useFetcher, X as RouterProvider, Xt as useLinkClickHandler, Y as RouterContextProvider, Yt as useInRouterContext, Z as Routes, Zt as useLoaderData, _ as routeRSCServerRequest, _n as useViewTransitionState, _t as createRoutesFromElements, a as createCookie, an as useOutletContext, at as WithErrorBoundaryProps, b as Await, bn as withHydrateFallbackProps, bt as createStaticRouter, c as createRequestHandler, cn as useResolvedPath, ct as createBrowserRouter, d as createSessionStorage, dn as useRouteError, dt as createContext, en as useMatches, et as SingleFetchRedirectSymbol, f as deserializeErrors, fn as useRouteLoaderData, ft as createHashRouter, g as isSession, gn as useSubmit, gt as createRoutesFromChildren, h as isCookie, hn as useSearchParams, ht as createRouter, i as ServerRouter, in as useOutlet, it as WithComponentProps, j as HistoryRouter, jt as matchRoutes, k as FrameworkContext, kt as mapRouteProperties, l as createRoutesStub, ln as useRevalidator, lt as createClientRoutes, m as href, mn as useScrollRestoration, mt as createPath, n as RSCStaticRouter, nn as useNavigation, nt as StaticRouterProvider, o as createCookieSessionStorage, on as useParams, ot as WithHydrateFallbackProps, p as getHydrationData, pn as useRoutes, pt as createMemoryRouter, q as RouteContext, qt as useFormAction, r as ServerMode, rn as useNavigationType, rt as ViewTransitionContext, s as createMemorySessionStorage, sn as usePrompt, st as createBrowserHistory, t as RSCDefaultRootErrorBoundary, tn as useNavigate, tt as StaticRouter, u as createSession, un as useRoute, ut as createClientRoutesWithHMRRevalidationOptOut, v as setDevServerHooks, vn as withComponentProps, vt as createSearchParams, w as DataRouterContext, wt as getPatchRoutesOnNavigationFunction, x as AwaitContextProvider, xt as data, y as Action, yn as withErrorBoundaryProps, yt as createStaticHandler2, z as Meta, zt as useActionData } from "./development-DdHy0Th9.js";
import { t as require_react_dom } from "./react-dom-B5FdNCyq.js";

//#region node_modules/react-router/dist/development/dom-export.mjs
/**
* react-router v7.10.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var import_react_dom$1 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function RouterProvider2(props) {
	return /* @__PURE__ */ import_react.createElement(RouterProvider, {
		flushSync: import_react_dom.flushSync,
		...props
	});
}
var ssrInfo = null;
var router = null;
function initSsrInfo() {
	if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {
		if (window.__reactRouterManifest.sri === true) {
			const importMap = document.querySelector("script[rr-importmap]");
			if (importMap?.textContent) try {
				window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;
			} catch (err) {
				console.error("Failed to parse import map", err);
			}
		}
		ssrInfo = {
			context: window.__reactRouterContext,
			manifest: window.__reactRouterManifest,
			routeModules: window.__reactRouterRouteModules,
			stateDecodingPromise: void 0,
			router: void 0,
			routerInitialized: false
		};
	}
}
function createHydratedRouter({ getContext, unstable_instrumentations }) {
	initSsrInfo();
	if (!ssrInfo) throw new Error("You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`");
	let localSsrInfo = ssrInfo;
	if (!ssrInfo.stateDecodingPromise) {
		let stream = ssrInfo.context.stream;
		invariant(stream, "No stream found for single fetch decoding");
		ssrInfo.context.stream = void 0;
		ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {
			ssrInfo.context.state = value.value;
			localSsrInfo.stateDecodingPromise.value = true;
		}).catch((e) => {
			localSsrInfo.stateDecodingPromise.error = e;
		});
	}
	if (ssrInfo.stateDecodingPromise.error) throw ssrInfo.stateDecodingPromise.error;
	if (!ssrInfo.stateDecodingPromise.value) throw ssrInfo.stateDecodingPromise;
	let routes = createClientRoutes(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);
	let hydrationData = void 0;
	if (ssrInfo.context.isSpaMode) {
		let { loaderData } = ssrInfo.context.state;
		if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && "root" in loaderData) hydrationData = { loaderData: { root: loaderData.root } };
	} else {
		hydrationData = getHydrationData({
			state: ssrInfo.context.state,
			routes,
			getRouteInfo: (routeId) => ({
				clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,
				hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,
				hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null
			}),
			location: window.location,
			basename: window.__reactRouterContext?.basename,
			isSpaMode: ssrInfo.context.isSpaMode
		});
		if (hydrationData && hydrationData.errors) hydrationData.errors = deserializeErrors(hydrationData.errors);
	}
	let router2 = createRouter({
		routes,
		history: createBrowserHistory(),
		basename: ssrInfo.context.basename,
		getContext,
		hydrationData,
		hydrationRouteProperties,
		unstable_instrumentations,
		mapRouteProperties,
		future: { middleware: ssrInfo.context.future.v8_middleware },
		dataStrategy: getTurboStreamSingleFetchDataStrategy(() => router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),
		patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)
	});
	ssrInfo.router = router2;
	if (router2.state.initialized) {
		ssrInfo.routerInitialized = true;
		router2.initialize();
	}
	router2.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;
	window.__reactRouterDataRouter = router2;
	return router2;
}
function HydratedRouter(props) {
	if (!router) router = createHydratedRouter({
		getContext: props.getContext,
		unstable_instrumentations: props.unstable_instrumentations
	});
	let [criticalCss, setCriticalCss] = import_react.useState(ssrInfo?.context.criticalCss);
	import_react.useEffect(() => {
		setCriticalCss(void 0);
	}, []);
	import_react.useEffect(() => {
		if (criticalCss === void 0) document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());
	}, [criticalCss]);
	let [location2, setLocation] = import_react.useState(router.state.location);
	import_react.useLayoutEffect(() => {
		if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {
			ssrInfo.routerInitialized = true;
			ssrInfo.router.initialize();
		}
	}, []);
	import_react.useLayoutEffect(() => {
		if (ssrInfo && ssrInfo.router) return ssrInfo.router.subscribe((newState) => {
			if (newState.location !== location2) setLocation(newState.location);
		});
	}, [location2]);
	invariant(ssrInfo, "ssrInfo unavailable for HydratedRouter");
	useFogOFWarDiscovery(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(FrameworkContext.Provider, { value: {
		manifest: ssrInfo.manifest,
		routeModules: ssrInfo.routeModules,
		future: ssrInfo.context.future,
		criticalCss,
		ssr: ssrInfo.context.ssr,
		isSpaMode: ssrInfo.context.isSpaMode,
		routeDiscovery: ssrInfo.context.routeDiscovery
	} }, /* @__PURE__ */ import_react.createElement(RemixErrorBoundary, { location: location2 }, /* @__PURE__ */ import_react.createElement(RouterProvider2, {
		router,
		unstable_useTransitions: props.unstable_useTransitions,
		unstable_onError: props.unstable_onError
	}))), /* @__PURE__ */ import_react.createElement(import_react.Fragment, null));
}
var renderedRoutesContext = createContext();

//#endregion
//#region node_modules/react-router-dom/dist/index.mjs
/**
* react-router-dom v7.10.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/

//#endregion
export { Await, BrowserRouter, Form, HashRouter, HydratedRouter, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, Link, Links, MemoryRouter, Meta, NavLink, Navigate, Action as NavigationType, Outlet, PrefetchPageLinks, Route, Router, RouterContextProvider, RouterProvider2 as RouterProvider, Routes, Scripts, ScrollRestoration, ServerRouter, StaticRouter, StaticRouterProvider, AwaitContextProvider as UNSAFE_AwaitContextProvider, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, ErrorResponseImpl as UNSAFE_ErrorResponseImpl, FetchersContext as UNSAFE_FetchersContext, FrameworkContext as UNSAFE_FrameworkContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RSCDefaultRootErrorBoundary as UNSAFE_RSCDefaultRootErrorBoundary, RemixErrorBoundary as UNSAFE_RemixErrorBoundary, RouteContext as UNSAFE_RouteContext, ServerMode as UNSAFE_ServerMode, SingleFetchRedirectSymbol as UNSAFE_SingleFetchRedirectSymbol, ViewTransitionContext as UNSAFE_ViewTransitionContext, WithComponentProps as UNSAFE_WithComponentProps, WithErrorBoundaryProps as UNSAFE_WithErrorBoundaryProps, WithHydrateFallbackProps as UNSAFE_WithHydrateFallbackProps, createBrowserHistory as UNSAFE_createBrowserHistory, createClientRoutes as UNSAFE_createClientRoutes, createClientRoutesWithHMRRevalidationOptOut as UNSAFE_createClientRoutesWithHMRRevalidationOptOut, createRouter as UNSAFE_createRouter, decodeViaTurboStream as UNSAFE_decodeViaTurboStream, deserializeErrors as UNSAFE_deserializeErrors, getHydrationData as UNSAFE_getHydrationData, getPatchRoutesOnNavigationFunction as UNSAFE_getPatchRoutesOnNavigationFunction, getTurboStreamSingleFetchDataStrategy as UNSAFE_getTurboStreamSingleFetchDataStrategy, hydrationRouteProperties as UNSAFE_hydrationRouteProperties, invariant as UNSAFE_invariant, mapRouteProperties as UNSAFE_mapRouteProperties, shouldHydrateRouteLoader as UNSAFE_shouldHydrateRouteLoader, useFogOFWarDiscovery as UNSAFE_useFogOFWarDiscovery, useScrollRestoration as UNSAFE_useScrollRestoration, withComponentProps as UNSAFE_withComponentProps, withErrorBoundaryProps as UNSAFE_withErrorBoundaryProps, withHydrateFallbackProps as UNSAFE_withHydrateFallbackProps, createBrowserRouter, createContext, createCookie, createCookieSessionStorage, createHashRouter, createMemoryRouter, createMemorySessionStorage, createPath, createRequestHandler, createRoutesFromChildren, createRoutesFromElements, createRoutesStub, createSearchParams, createSession, createSessionStorage, createStaticHandler2 as createStaticHandler, createStaticRouter, data, generatePath, href, isCookie, isRouteErrorResponse, isSession, matchPath, matchRoutes, parsePath, redirect, redirectDocument, renderMatches, replace, resolvePath, HistoryRouter as unstable_HistoryRouter, RSCStaticRouter as unstable_RSCStaticRouter, routeRSCServerRequest as unstable_routeRSCServerRequest, setDevServerHooks as unstable_setDevServerHooks, usePrompt as unstable_usePrompt, useRoute as unstable_useRoute, useActionData, useAsyncError, useAsyncValue, useBeforeUnload, useBlocker, useFetcher, useFetchers, useFormAction, useHref, useInRouterContext, useLinkClickHandler, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes, useSearchParams, useSubmit, useViewTransitionState };
//# sourceMappingURL=react-router-dom.js.map